{
    "contents" : "# each function returns a numeric vector of values, length == nrow(possible_patterns)\n\nMI <- function(which_not_answered, possible_patterns, person, test, row_loc){\n    infos <- lapply(which_not_answered, function(x)\n        iteminfo(extract.item(test$mirt_object, x), Theta=person$thetas))\n    crit <- do.call(c, infos)\n    crit\n}\n\nMEI <- function(which_not_answered, possible_patterns, person, test, row_loc){\n    P <- numeric(nrow(possible_patterns))\n    for(i in which_not_answered){\n        ii <- extract.item(test$mirt_object, i)\n        p <- probtrace(ii, person$thetas)\n        P[row_loc == i] <- p\n    }\n    infostmp <- lapply(which_not_answered, function(x)\n        iteminfo(extract.item(test$mirt_object, x), Theta=person$thetas, total.info = FALSE))\n    infostmp <- as.list(do.call(c, infostmp))\n    infos <- weighted_mat(P=P, mat=infostmp, row_loc=row_loc, which_not_answered=which_not_answered)\n    crit <- do.call(c, infos)\n    crit\n}\n\nMEPV <- function(which_not_answered, possible_patterns, person, test, row_loc){\n    P <- numeric(nrow(possible_patterns))\n    for(i in which_not_answered){\n        ii <- extract.item(test$mirt_object, i)\n        p <- probtrace(ii, person$thetas)\n        P[row_loc == i] <- p\n    }\n    pp2 <- possible_patterns\n    pp2[ ,which(possible_patterns[1L, ] == possible_patterns[2L,])] <- NA\n    acovstmp <- getAcovs(pp2, method = 'MAP')\n    acovs <- weighted_mat(P=P, mat=acovstmp, row_loc=row_loc, which_not_answered=which_not_answered)\n    crit <- do.call(c, acovs)\n    crit\n}\n\nMLWI <- function(which_not_answered, possible_patterns, person, test, row_loc){\n    Theta <- test$ThetaGrid\n    density <- test$density\n    LL <- vector('list', nrow(possible_patterns))\n    ll <- log(mirt:::computeItemtrace(pars = test$mirt_object@pars,\n                                 Theta=Theta, \n                                 itemloc = test$mirt_object@itemloc,\n                                 CUSTOM.IND=list()))\n    for(i in 1L:nrow(possible_patterns)){\n        pick <- !is.na(possible_patterns[i,])\n        tmp <- test$itemloc2[pick] + possible_patterns[i, pick]\n        LL[[i]] <- exp(rowSums(ll[,tmp]))\n    }\n    infostmp <- lapply(which_not_answered, function(x)\n        iteminfo(extract.item(test$mirt_object, x), Theta=Theta))\n    uniq <- unique(row_loc)\n    count <- 1L\n    for(i in uniq){\n        LL[i == row_loc] <- lapply(LL[i == row_loc], function(x, C)\n            return(x * C), C=infostmp[[count]])\n        count <- count + 1L\n    }\n    infos <- weighted_mat(mat=LL, row_loc=row_loc, which_not_answered=which_not_answered)\n    crit <- do.call(c, lapply(infos, function(y, x) integrate.xy(x, y), x=Theta))\n    crit\n}\n\nMPWI <- function(which_not_answered, possible_patterns, person, test, row_loc){\n    Theta <- test$ThetaGrid\n    density <- test$density\n    LL <- vector('list', nrow(possible_patterns))\n    ll <- log(mirt:::computeItemtrace(pars = test$mirt_object@pars,\n                                      Theta=Theta, \n                                      itemloc = test$mirt_object@itemloc,\n                                      CUSTOM.IND=list()))\n    for(i in 1L:nrow(possible_patterns)){\n        pick <- !is.na(possible_patterns[i,])\n        tmp <- test$itemloc2[pick] + possible_patterns[i, pick]\n        LL[[i]] <- exp(rowSums(ll[,tmp]))\n    }\n    infostmp <- lapply(which_not_answered, function(x)\n        iteminfo(extract.item(test$mirt_object, x), Theta=Theta))\n    uniq <- unique(row_loc)\n    count <- 1L\n    for(i in uniq){\n        LL[i == row_loc] <- lapply(LL[i == row_loc], function(x, C, dd)\n            return(x * C * dd), C=infostmp[[count]], dd=test$density)\n        count <- count + 1L\n    }\n    infos <- weighted_mat(mat=LL, row_loc=row_loc, which_not_answered=which_not_answered)\n    crit <- do.call(c, lapply(infos, function(y, x) integrate.xy(x, y), x=Theta))\n    crit\n}\n\nDrule <- function(which_not_answered, possible_patterns, person, test, row_loc, method){\n    acovs <- getAcovs(possible_patterns, method)\n    crit <- do.call(c, lapply(acovs, det))\n    crit\n}\n\nErule <- function(which_not_answered, possible_patterns, person, test, row_loc, method){\n    acovs <- getAcovs(possible_patterns, method)\n    crit <- do.call(c, lapply(acovs, function(x) eigen(x)$values[1L]))\n    crit\n}\n\nTrule <- function(which_not_answered, possible_patterns, person, test, row_loc, method, design){\n    acovs <- getAcovs(possible_patterns, method)\n    infos <- lapply(acovs, function(x){\n        ret <- try(solve(x), TRUE)\n        if(is(ret, 'try-error'))\n            ret <- matrix(0, nrow(x), ncol(x))\n        ret\n    })\n    crit <- do.call(c, lapply(infos, function(x, w) sum(diag(x) * w), \n                              w=design$Wrule_weights[!design$met_SEM]))\n    crit\n}\n\nWrule <- function(which_not_answered, possible_patterns, person, test, row_loc, method, design){\n    acovs <- getAcovs(possible_patterns, method)\n    infos <- lapply(acovs, function(x){\n        ret <- try(solve(x), TRUE)\n        if(is(ret, 'try-error'))\n            ret <- matrix(0, nrow(x), ncol(x))\n        ret\n    })\n    crit <- do.call(c, lapply(infos, function(x, w) w %*% x %*% w, \n                              w=design$Wrule_weights[!design$met_SEM]))\n    crit\n}\n\nKL <- function(which_not_answered, possible_patterns, person, test, row_loc, delta,\n               thetas = NULL){\n    info <- numeric(length(which_not_answered))\n    if(is.null(thetas)){\n        thetas <- person$thetas\n        for(i in 1L:length(which_not_answered)){\n            ii <- extract.item(test$mirt_object, which_not_answered[i])\n            p0 <- probtrace(ii, thetas - delta)\n            p1 <- probtrace(ii, thetas + delta)\n            info[i] <- sum(p1 * (log(p1) - log(p0)))\n        }\n    } else {\n        info <- matrix(0, nrow(thetas), length(which_not_answered))\n        for(i in 1L:length(which_not_answered)){\n            ii <- extract.item(test$mirt_object, which_not_answered[i])\n            p0 <- probtrace(ii, thetas)\n            p1 <- probtrace(ii, person$thetas)\n            info[,i] <- rowSums(t(p1[1L,] * t(matrix(log(p1), nrow(thetas), length(p1), byrow=TRUE)\n                                          - log(p0))))\n        }\n    }    \n    return(info)\n}\n\nIKL <- function(which_not_answered, possible_patterns, person, test, row_loc, delta,\n                den=FALSE){\n    Theta <- matrix(seq(person$thetas-delta, person$thetas+delta, length.out=test$quadpts))\n    LL <- vector('list', nrow(possible_patterns))\n    ll <- log(mirt:::computeItemtrace(pars = test$mirt_object@pars,\n                                      Theta=Theta, \n                                      itemloc = test$mirt_object@itemloc,\n                                      CUSTOM.IND=list()))\n    for(i in 1L:nrow(possible_patterns)){\n        pick <- !is.na(possible_patterns[i,])\n        tmp <- test$itemloc2[pick] + possible_patterns[i, pick]\n        LL[[i]] <- exp(rowSums(ll[,tmp]))\n    }\n    KLcrit <- KL(which_not_answered=which_not_answered, possible_patterns=possible_patterns,\n               person=person, test=test, row_loc=row_loc, thetas=Theta,\n               delta=NA)\n    uniq <- unique(row_loc)\n    count <- 1L\n    dd <- if(den){\n        dd <- mirt:::mirt_dmvnorm(Theta, test$gp$gmeans, test$gp$gcov) \n    } else 1\n    for(i in uniq){\n        LL[i == row_loc] <- lapply(LL[i == row_loc], function(x, C, dd)\n            return(x * C * dd), C=KLcrit[[count]], dd=dd)\n        count <- count + 1L\n    }\n    infos <- weighted_mat(mat=LL, row_loc=row_loc, which_not_answered=which_not_answered)\n    crit <- do.call(c, lapply(infos, function(y, x) integrate.xy(x, y), x=Theta))\n    return(crit)\n}",
    "created" : 1411246854338.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2511447200",
    "id" : "24122A4F",
    "lastKnownWriteTime" : 1411247061,
    "path" : "~/Desktop/Git/mirtCAT/R/selection_criteria.R",
    "project_path" : "R/selection_criteria.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}