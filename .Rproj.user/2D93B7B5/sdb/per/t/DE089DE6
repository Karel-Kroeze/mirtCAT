{
    "contents" : "#' Generate an adaptive or non-adaptive test HTML interface\n#' \n#' Provides tools to generate an HTML interface for creating adaptive and \n#' non-adaptive educational and psychological tests using the shiny package. Suitable for \n#' applying unidimensional and multidimensional computerized adaptive tests using item \n#' response theory methodology. Test scoring is performed using the \\code{mirt} package.\n#' However, if no scoring is required (i.e., a standard survey) then defining a \\code{mirt} \n#' object may be omitted.\n#' \n#' All tests will stop once the \\code{'min_SEM'} criteria has been reached. If all questions should\n#' be answered, users should specify an extremely small \\code{'min_SEM'} or equivalently \n#' a large \\code{'min_items'} criteria.\n#' \n#' @param questions a named list containing \\code{shiny} input definitions for each item. \n#'   Each element of the input should be a list of the form \n#'   \\code{list(item1 = shinyInput(), item2 = shinyInput(), ...)}. \n#'   Each \\code{inputID} must be \\bold{identical} to the column names used to define the data \n#'   from the \\code{mirt_object} input (if applicable)\n#'   \n#' @param mirt_object single group object defined by the \\code{mirt} package. This is required\n#'   if the test is to be scored adaptively or non-adaptively, but not required for general \n#'   questionnaires\n#'   \n#' @param method argument passed to \\code{mirt::fscores()} for computing new scores in the CAT \n#'   stage. Default is 'MAP'\n#' \n#' @param criteria adaptive criteria used, default is to administer each item sequentially \n#'   using \\code{criteria = 'seq'}. \n#' \n#'   Possible inputs for unidimensional adaptive tests include: \\code{'MI'} for the maximum\n#'   information, \\code{'MEPV'} for minimum expected posterior variance, \n#'   \\code{'MLWI'} for maximum likelihood weighted information, \n#'   \\code{'MPWI'} for maximum posterior weighted information, \\code{'MEI'} for \n#'   maximum expected information, and \\code{'IKLP'} as well as \\code{'IKL'} for the \n#'   integration based Kullback-Leibler criteria with and without the prior density weight,\n#'   respectively, and their root-nitems administered weighted counter-parts, \\code{'IKLn'} and \n#'   \\code{'IKLPn'}.\n#'   \n#'   Possible inputs for multidimensional adaptive tests include: \\code{'Drule'} \n#'   for the maximum determinant of the information matrix, \\code{'Trule'} for the \n#'   maximum (potentially weighted) trace of the information matrix, \\code{'Erule'} for the \n#'   minimum value of the information matrix, and \\code{'Wrule'} for \n#'   the weighted information criteria. For each of these rules, the posterior weight for \n#'   the latent trait scores can also be included with the \\code{'DPrule'}, \\code{'TPrule'},\n#'   \\code{'EPrule'}, \\code{'WPrule'}, respectively. As a safety precaution, if the \n#'   selected criteria do not weight by the posterior (and therefore do not exist for \n#'   extreme response styles) and less than 5 items have been administered then \n#'   the method is temporarily switched to the posterior weighting\n#'   until a variable response pattern is observed.\n#'   \n#'   Applicable to both unidimensional and multidimensional tests are the\n#'   \\code{'KL'} and \\code{'KLn'} for point-wise Kullback-Leibler divergence and \n#'   point-wise Kullback-Leibler with a decreasing delta value (\\code{delta*sqrt(n)}, \n#'   where \\code{n} is the number of items previous answered), respectively. \n#'   The \\code{delta} criteria is defined in the \\code{design} object\n#'   \n#'   Non-adaptive methods applicable even when no \\code{mirt_object} is passed \n#'   are: \\code{'random'} to randomly select items, and \\code{'seq'} for selecting \n#'   items sequentially.\n#'   \n#' @param item_answers a character vector indicating which item should be considered 'correct'\n#'   when scoring individuals. Must be the length of the test, where \\code{NA}s are used if the \n#'   item is not to be scored\n#'   \n#' @param start_item a single number indicating which item should be used as the start item.\n#'   Default is 1\n#'   \n#' @param exposure a numeric vector specifying the amount of exposure control to apply for\n#'   each successive item. The default vector of 1's selects items which demonstrate \n#'   the maximum CAT critiera (i.e., no exposure control), however if the item exposure \n#'   is greater than 1, and \\code{exposure[item] == n}, then the \\code{n} most optimal\n#'   criteria will be randomly sampled from. For instance, if \n#'   \\code{exposure[5] == 3}, and \\code{critiera = 'MI'}, then when the fifth item is to be \n#'   selected from the remaining pool of items the top 3 candidate items demonstrating \n#'   the largest information criteria will be sampled from. Naturally, the first and last \n#'   elements of \\code{exposure} are ignored since exposure control will be meaningless\n#' \n#' @param local_pattern a character or numeric vector of response patterns \n#'   used to run the CAT application without generating the GUI interface. \n#'   This option requires a complete response pattern to be supplied. \\code{local_pattern} \n#'   is required to be numeric if no \\code{questions} list is input, otherwise it must be a \n#'   character vector of plausible responses\n#'   \n#' @param design_elements logical; return an object containing the test, person, and design \n#'   elements? Primarily this is to be used with the \\code{\\link{findNextItem}} function\n#'   \n#' @param design a list of design based parameters for adaptive and non-adaptive tests. \n#'   These can be\n#' \n#' \\describe{\n#'   \\item{\\code{min_SEM}}{Default is \\code{0.3}; minimum standard error or measurement\n#'     to be reached for the latent traits (thetas) before the test is stopped. If the test is\n#'     multidimensional, either a single value or a vector of values may be supplied to provide\n#'     SEM criteria values for each dimension}\n#'     \n#'   \\item{\\code{thetas.start}}{a numeric vector of starting values for the theta parameters.\n#'     Default is \\code{rep(0, nfact)}}\n#'   \n#'   \\item{\\code{min_items}}{minimum number of items that must be answered \n#'     before the test is stopped. Default is \\code{1}}\n#'   \n#'   \\item{\\code{max_items}}{maximum number of items that \n#'     can be answered. Default is the length of the item bank}\n#'   \n#'   \\item{\\code{quadpts}}{Number of quadrature points used per dimension \n#'     for integration (if required). Default is identical to scheme in \\code{\\link{fscores}}}\n#'   \n#'   \\item{\\code{theta_range}}{upper and lower range for the theta \n#'     integration grid. Used in conjunction with \\code{quadpts} to generate an equally spaced \n#'     quadrature grid. Default is \\code{c(-6,6)}}\n#' \n#'   \\item{\\code{Wrule_weights}}{weights used when \\code{criteria == 'Wrule'}. The default \n#'     weights the latent dimensions equally. Default is \\code{rep(1/nfact), nfact)}, \n#'     where \\code{nfact} is the number of test dimensions;  }\n#'     \n#'   \\item{\\code{KL_delta}}{interval range used when \\code{criteria = 'KL'}\n#'     or \\code{criteria = 'KLn'}. Default is \\code{0.1}}\n#'     \n#'   \\item{\\code{max_time}}{maximum time allowed for the generated GUI, measured\n#'     in seconds. For instance, if the test should stop after 10 minutes then the number \n#'     600 should be passed (10 * 60). Default is \\code{Inf}, therefore no time limit}\n#'     \n#'   \\item{\\code{content}}{an optional character vector indicating the type of content measured\n#'     by an item. Must be supplied in conjunction with \\code{content_prop}}\n#'     \n#'   \\item{\\code{content_prop}}{an optional named numeric numeric vector indicating the \n#'     distribution of item content proportions. A \\code{content} vector must also be supplied\n#'     to indicate the item content membership. For instance, if \\code{content} contains three\n#'     possible item content domains 'Addition', 'Subtraction', and 'Multiplication', and the \n#'     test should contain approximately half multiplication and a quarter of both \n#'     addition and subtraction, then a suitable input would be \n#'     \n#'     \\code{content_prop = c('Addition'=0.25, 'Subtraction'=0.25, 'Multiplication'=.5)}\n#'     \n#'     Note that \\code{content_prop} must sum to 1 in order to represent valid population \n#'     proportions.\n#'     }\n#'   \n#' }\n#' \n#' @param shinyGUI a list of GUI based parameters to be over-written. These can be\n#' \n#' \\describe{\n#'   \\item{\\code{title}}{A character string for the test title. Default is \n#'     \\code{'mirtCAT'}}\n#'   \n#'   \\item{\\code{authors}}{A character string for the author names. Default is \n#'     \\code{'Author of survey'}}\n#'\n#'   \\item{\\code{firstpage}}{The first page of the shiny GUI. Default prints the title\n#'     and information message\n#'     \n#'     \\preformatted{ \n#'          list(h1('Welcome to the mirtCAT interface'),\n#'               The following interface was created using the mirtCAT package. \n#'               To cite the package use citation(\\\\'mirtCATd\\\\') in R.')\n#'          }\n#'       }\n#' \n#'   \\item{\\code{demographics}}{The person information page used in the GUI for collecting \n#'     demographic information generated using tools from the shiny package. The default \n#'     collects only the respondent gender using the format \n#'  \n#'     \\preformatted{ \n#'          list(selectInput(inputId = 'gender',\n#'                   label = 'Please select your gender.',\n#'                   choices = c('', 'Male', 'Female', 'Other'),\n#'                   selected = ''))\n#'         }\n#'      }\n#'      \n#'   \\item{\\code{demographics_inputIDs}}{a character vector required if a custom demographics\n#'     input is used. Default is \\code{demographics_inputIDs = 'gender'}, corresponding to\n#'     the \\code{demographics} default}\n#'     \n#'   \\item{\\code{stem_locations}}{a character vector of paths pointing to .png, .jpeg, or .gif\n#'     files to be used as item stems. Must be the length of the test, where \\code{NA}s are \n#'     used if the item has no corresponding file}\n#'     \n#'   \\item{\\code{temp_file}}{a character vector indicating where a temporary .rds file \n#'     containing the response information should be saved while the GUI is running. \n#'     The object will be saved after each item is successfully completed. This is used to \n#'     save response information to the hard drive in case there are power outages or \n#'     unexpected computer restarts.      \n#'     \n#'     If \\code{NULL}, no temp file will be created. Upon completion of the test, the \n#'     temp file will be deleted}\n#'     \n#'   \\item{\\code{resume_file}}{a character vector indicating where a temporary .rds file \n#'     containing the response information was saved (see \\code{temp_file}). Allows the GUI\n#'     session to be continued using the previously stored demographic and response pattern \n#'     information. Note that the demographics GUI page will appear again, but this information\n#'     will not be used and can be skipped.}\n#'     \n#'   \\item{\\code{lastpage}}{Last message indicating that the test has been completed \n#'     (i.e., criteria has been met). Default is \n#'   \n#'     \\preformatted{list(h5(\"End of survey. Click \\'Next\\' to save results \n#'       and close application.\"))}\n#'    }    \n#'   \n#' }\n#' \n#' @param preCAT a list object which can be used to specify a pre-CAT block in which \n#'   different test properties may be applied prior to beginning the CAT session. If the\n#'   list is empty, no preCAT block will be used. All of the following elements are required \n#'   to use the \\code{preCAT} input:\n#'   \n#'   \\describe{\n#'     \\item{\\code{nitems}}{number of items to administer before the CAT session begins.\n#'       An input greater than 0 is required}\n#'     \n#'     \\item{\\code{criteria}}{selection criteria (see above). Default is 'random'}\n#'     \n#'     \\item{\\code{method}}{selection criteria (see above). It is generally recommended to \n#'       select a method which can deal with all-or-none response patterns, such as 'EAP'\n#'       or 'MAP', or in the multidimensional case 'DPrule' or 'TPrule'. Default is 'MAP'}\n#'    }\n#' \n#' @export mirtCAT\n#' @author Phil Chalmers \\email{rphilip.chalmers@@gmail.com}\n#' @seealso \\code{\\link{generate_pattern}}\n#' \n#' @return Returns a list object of class \\code{'Person'} containing the following elements:\n#'   \n#' \\describe{\n#'   \\item{\\code{raw_responses}}{A numeric vector indicating the raws responses to the respective\n#'     items, where NA indicates the item was not answered}\n#'     \n#'   \\item{\\code{responses}}{A numeric vector of scored responses if the \\code{item_answers} input\n#'     was used for each respective item}\n#'   \n#'   \\item{\\code{items_answered}}{An integer vector indicating the order in which the items were \n#'     answered}\n#'   \n#'   \\item{\\code{thetas}}{A numeric vector indicating the final theta estimates}\n#'   \n#'   \\item{\\code{thetas_history}}{A matrix indicating the progression of updating the theta values\n#'     during the test}\n#'     \n#'   \\item{\\code{thetas_SE_history}}{A matrix indicating the standard errors for theta after each\n#'     successive item was answered}\n#'     \n#'   \\item{\\code{item_time}}{A numeric vector indicating how long the respondent took to answer\n#'     each question (in seconds)}\n#' \n#'   \\item{\\code{demographics}}{A data.frame object containing the information collected on the \n#'     first page of the shiny GUI. This is used to store the demographic information for each\n#'     participant} \n#' }\n#' \n#' @keywords CAT, MCAT, computerized adaptive testing\n#' \n#' @examples\n#' \\dontrun{\n#' \n#' # unidimensional scored example with generated items\n#' \n#' # model\n#' set.seed(1234)\n#' nitems <- 50\n#' itemnames <- paste0('Item.', 1:nitems)\n#' a <- matrix(rlnorm(nitems, .2, .3))\n#' d <- matrix(rnorm(nitems))\n#' dat <- simdata(a, d, 1000, itemtype = 'dich')\n#' colnames(dat) <- itemnames\n#' mod <- mirt(dat, 1)\n#' \n#' # simple math items\n#' shiny_questions <- questions <- vector('list', nitems)\n#' names(shiny_questions) <- names(questions) <- itemnames\n#' answers <- character(nitems)\n#' choices <- vector('list', nitems)\n#' spacing <- floor(d - min(d)) + 1 #easier items have more variation in the options\n#' \n#' for(i in 1:nitems){\n#'     n1 <- sample(1:50, 1)\n#'     n2 <- sample(51:100, 1)\n#'     ans <- n1 + n2\n#'     questions[[i]] <- paste0(n1, ' + ', n2, ' = ?')\n#'     answers[i] <- as.character(ans)\n#'     ch <- ans + sample(c(-5:-1, 1:5) * spacing[i,], 5)\n#'     ch[sample(1:5, 1)] <- ans\n#'     choices[[i]] <- as.character(ch)\n#' }\n#' \n#' for(i in 1L:nitems){\n#'     shiny_questions[[i]] <- radioButtons(inputId = itemnames[i],\n#'                                          label = questions[[i]],\n#'                                          choices = choices[[i]])\n#' }\n#' \n#' (res <- mirtCAT(shiny_questions)) #collect response only (no scoring or estimating thetas)\n#' (res <- mirtCAT(shiny_questions, mod, item_answers=answers)) #sequential scoring \n#' (res <- mirtCAT(shiny_questions, mod, item_answers=answers, criteria = 'random')) #random\n#' (res <- mirtCAT(shiny_questions, mod, item_answers=answers, criteria = 'MI')) #adaptive\n#' \n#' #-----------------------------------------\n#' \n#' # run locally, random response pattern given Theta\n#' set.seed(1)\n#' pat <- generate_pattern(mod, Theta = 0, choices = choices, item_answers=answers)\n#' head(pat)\n#' res <- mirtCAT(shiny_questions, mod, item_answers=answers, local_pattern=pat) #seq\n#' summary(res)\n#' \n#' # same as above, but using special input vector that doesn't require shiny\n#' set.seed(1)\n#' pat2 <- generate_pattern(mod, Theta = 0)\n#' head(pat2)\n#' print(mirtCAT(mirt_object=mod, local_pattern=pat2))\n#' \n#' # run CAT, and save results to object called person\n#' person <- mirtCAT(shiny_questions, mod, item_answers=answers, criteria = 'MI', \n#'   local_pattern=pat)\n#' print(person)\n#' summary(person)\n#' \n#' # plot the session\n#' plot(person) #standard errors\n#' plot(person, SE=1.96) #95 percent confidence intervals\n#' \n#' #-----------------------------------------\n#'\n#' ### save response object to temp directory in case session ends early\n#' wdf <- paste0(getwd(), '/temp_file.rds')\n#' res <- mirtCAT(shiny_questions, mod, item_answers=answers, shinyGUI=list(temp_file=wdf))\n#' \n#' # resume test this way if test was stopped early (and temp files were saved)\n#' res <- mirtCAT(shiny_questions, mod, item_answers=answers, shinyGUI=list(resume_file=wdf))\n#' print(res)\n#' \n#' }\nmirtCAT <- function(questions = NULL, mirt_object = NULL, method = 'MAP', criteria = 'seq', \n                    item_answers = NULL, start_item = 1, exposure = rep(1, length(questions)), \n                    local_pattern = NULL, design_elements=FALSE,\n                    design = list(), shinyGUI = list(), preCAT = list(), ...)\n{    \n    on.exit({MCE$person <- MCE$test <- MCE$design <- MCE$shinyGUI <- MCE$start_time <- \n                MCE$STOP <- MCE$outfile <- MCE$last_demographics <- NULL})\n    if(is.null(questions)){\n        questions <- vector('list', ncol(mirt_object@Data$data))\n        Names <- colnames(mirt_object@Data$data)\n        names(questions) <- Names\n        K <- mirt_object@Data$K\n        for(i in 1L:length(K))\n            questions[[i]] <- selectInput(inputId = Names[i], label = '', \n                                          choices = as.character(0L:(K[i]-1L)))\n        item_answers <- NULL\n    }\n        \n    if(is.null(names(questions)))\n        stop('questions list must have names')\n    if(is.null(mirt_object)){\n        dat <- matrix(c(0,1), 2L, length(questions))\n        colnames(dat) <- names(questions)\n        mirt_object <- mirt(dat, 1L, TOL=NaN)\n        score <- FALSE\n        if(!(criteria %in% c('seq', 'random')))\n            stop('Only random and seq criteria are available if no mirt_object was defined')\n        mirt_mins <- rep(1L, ncol(dat))\n    } else {\n        score <- TRUE\n        mirt_mins <- mirt_object@Data$mins\n    }\n    if(!is.null(local_pattern))\n        if(is.numeric(local_pattern))\n            local_pattern <- local_pattern - mirt_mins\n    itemnames <- colnames(mirt_object@Data$data)\n    if(length(itemnames) != length(questions) || !all(itemnames %in% names(questions)))\n        stop('Item names for mirt_object and questions do not match')\n    item_options <- lapply(questions, extract_choices)\n    \n    #setup objects\n    shinyGUI_object <- ShinyGUI$new(questions=questions, shinyGUI=shinyGUI)\n    test_object <- Test$new(mirt_object=mirt_object, item_answers_in=item_answers, \n                     item_options=item_options, quadpts_in=design$quadpts,\n                     theta_range_in=design$theta_range, dots=list(...))\n    design_object <- Design$new(method=method, criteria=criteria, start_item=start_item,\n                         nfact=test_object$nfact, design=design, exposure=exposure,\n                         preCAT=preCAT, nitems=test_object$length)\n    person_object <- Person$new(nfact=test_object$nfact, nitems=length(test_object$itemnames), \n                         thetas.start_in=design$thetas.start, score=score)\n    if(!is.null(shinyGUI$resume_file)){\n        person_object <- readRDS(shinyGUI$resume_file)\n        MCE$last_demographics <- person_object$demographics\n    }\n    if(design_elements){\n        ret <- list(person=person_object, test=test_object, design=design_object)\n        class(ret) <- \"mirtCAT_design\"\n        return(ret)\n    }\n    \n    #put in specific enviroment\n    MCE$person <- person_object\n    MCE$test <- test_object\n    MCE$design <- design_object\n    MCE$shinyGUI <- shinyGUI_object\n    MCE$STOP <- FALSE\n    MCE$outfile <- tempfile(fileext='.png')\n    \n    if(length(local_pattern)){\n        person <- run_local(as.character(local_pattern))\n        person$item_time <- numeric(0)\n    } else {\n        runApp(list(ui = ui(), server = server), launch.browser=TRUE)\n        person <- MCE$person\n    }\n    person$items_answered <- person$items_answered[!is.na(person$items_answered)]\n    ret <- list(raw_responses=person$raw_responses + 1L, \n                responses=as.numeric(person$responses + mirt_mins),\n                items_answered=person$items_answered,\n                thetas=person$thetas,\n                thetas_history=person$thetas_history,\n                thetas_SE_history=person$thetas_SE_history,\n                item_time=person$item_time,\n                demographics=person$demographics)\n    colnames(ret$thetas) <- colnames(ret$thetas_history) <-\n        colnames(ret$thetas_SE_history) <- paste0('Theta_', 1L:MCE$test$nfact)\n    if(!person$score)\n        ret$thetas <- ret$thetas_history <- ret$thetas_SE_history <- NA\n    class(ret) <- 'mirtCAT'\n    ret\n}",
    "created" : 1411249907872.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4275845079",
    "id" : "DE089DE6",
    "lastKnownWriteTime" : 1411248045,
    "path" : "~/Desktop/Git/mirtCAT/R/mirtCAT.R",
    "project_path" : "R/mirtCAT.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}