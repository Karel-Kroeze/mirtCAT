{
    "contents" : "#' Generate an adaptive or non-adaptive test HTML interface\n#' \n#' Provides tools to generate an HTML interface for creating adaptive and \n#' non-adaptive educational and psychological tests using the shiny package. Suitable for \n#' applying unidimensional and multidimensional computerized adaptive tests using item \n#' response theory methodology. Test scoring is performed using the \\code{mirt} package.\n#' However, if no scoring is required (i.e., a standard survey) then defining a \\code{mirt} \n#' object may be omitted.\n#' \n#' All tests will stop once the \\code{'min_SEM'} criteria has been reached. If all questions should\n#' be answered, users should specify an extremely small \\code{'min_SEM'} or equivalently \n#' a large \\code{'min_items'} criteria.\n#' \n#' @param questions a named list containing lists of \\code{shiny} input types for each item. \n#'   Each element of the input should be a list of the form \n#'   \\code{list(item1 = shinyInput(), item2 = shinyInput(), ...)}. \n#'   Each \\code{inputID} must be identical to the column names used to define the data \n#'   from the \\code{mirt_object} input\n#'   \n#' @param mirt_object single group object defined by the \\code{mirt} package. This is required\n#'   if the test is to be scored adaptively\n#'   \n#' @param method argument passed to \\code{mirt::fscores()} for computing new scores. Default is 'MAP'\n#' \n#' @param criteria adaptive criteria used, default is to administer each item sequentially \n#'   (i.e., \\code{criteria = 'seq'}). \n#' \n#'   Possible inputs for unidimensional adaptive tests include: \\code{'MI'} for the maximum\n#'   information, \\code{'MEPV'} for minimum expected posterior variance, \n#'   \\code{'MLWI'} for maximum likelihood weighted information, \n#'   \\code{'MPWI'} for maximum posterior weighted information, \\code{'MEI'} for \n#'   maximum expected information, and \\code{'IKLP'} as well as \\code{'IKL'} for the \n#'   Integration based Kullback-Leibler criteria with and without the prior density weight,\n#'   respectively, and their root-nitem weighted counter-parts \\code{'IKLn'} and \n#'   \\code{'IKLPn'}.\n#'   \n#'   Possible inputs for multidimensional adaptive tests include: \\code{'Drule'} \n#'   for the maximum determinant of the information matrix, \\code{'Trule'} for the \n#'   maximum (potentially weighted) trace of the information matrix, \\code{'Erule'} for the \n#'   minimum value of the information matrix, and \\code{'Wrule'} for \n#'   the weighted information criteria. For each of these rules the posterior weight for \n#'   the latent trait scores can also be included with the \\code{'DPrule'}, \\code{'TPrule'},\n#'   \\code{'EPrule'}, \\code{'WPrule'}, respectively. As a safety precaution, if the \n#'   selected criteria do not weight by the posterior (and therefore do not exist for \n#'   extreme response styles) the method is temporarily switched to the posterior weighting\n#'   until a variable response pattern is observed and more than 5 items have been administered.\n#'   \n#'   Applicable to both unidimensional and multidimensional tests are the\n#'   \\code{'KL'} and \\code{'KLn'} for point-wise Kullback-Leibler divergence and \n#'   point-wise Kullback-Leibler with a decreasing delta value (\\code{delta*sqrt(n)}, \n#'   where \\code{n} is the number of items previous answered), respectively. \n#'   The \\code{delta} criteria is defined in the \\code{design} object\n#'   \n#'   Non-adaptive methods which are applicable even when no \\code{mirt_object} is passed \n#'   include \\code{'random'} to randomly select items and \\code{'seq'} for selecting \n#'   items sequentially.\n#'   \n#' @param item_answers a character vector indicating which item should be considered 'correct'\n#'   when scoring individuals. Must be the length of the test, where \\code{NA}s are used if the \n#'   item is not scored\n#'   \n#' @param start_item a single number indicating which item should be used as the start item.\n#'   Default is 1\n#'   \n#' @param exposure a numeric vector specifying the amount of exposure control to apply for\n#'   each successive item. The default accepts the item which demonstrates the maximum CAT \n#'   critiera, however if the item exposure is greater than 1, and \\code{exposure[item] == n}, \n#'   then the \\code{n} most optimal criteria will be randomly sampled from. For instance, if \n#'   \\code{exposure[item] == 3}, and \\code{critiera = 'MI'}, then the 3 items demonstrating \n#'   the largest information criteria will be sampled from. Naturally, the first and last \n#'   elements are ignored for the first and last items, respectively \n#' \n#' @param local_pattern a character or numeric vector used to run the CAT application without \n#'   the GUI interface given a specific response pattern. This option requires a complete response \n#'   pattern to be supplied. This input is required to be numeric if no \\code{questions} list is\n#'   input\n#'   \n#' @param design a list of design based parameters for adaptive and non-adaptive tests. \n#'   These can be\n#' \n#' \\describe{\n#'   \\item{\\code{min_SEM}}{Default is \\code{0.3}; minimum standard error for the latent traits \n#'     (thetas) before the test is stopped. If the test is multidimensional either a single \n#'     value or a vector may be supplied to provide an overall minimum criteria or a SEM \n#'     value for each dimension, respectively}\n#'     \n#'   \\item{\\code{thetas.start}}{a numeric vector of starting values for the theta parameters.\n#'     Default is \\code{rep(0, nfact)}}\n#'   \n#'   \\item{\\code{min_items}}{Default is \\code{1}; minimum number of items that must be answered \n#'     before the test is stopped}\n#'   \n#'   \\item{\\code{max_items}}{Default is the length of the item bank; maximum number of items that \n#'     can be answered}\n#'   \n#'   \\item{\\code{quadpts}}{Number of quadrature points used per dimension \n#'     for integration (if required). Default is 61}\n#'   \n#'   \\item{\\code{theta_range}}{Default is \\code{c(-6,6)}; upper and lower range for the theta \n#'     integration grid. Used in conjunction with \\code{quadpts} to generate an equally spaced \n#'     quadrature grid}\n#' \n#'   \\item{\\code{Wrule_weights}}{Default is \\code{rep(1/nfact), nfact)}, where \\code{nfact} \n#'     is the number of test dimensions; weights used when \\code{criteria == 'Wrule'}. The default \n#'     weights the latent dimensions equally }\n#'     \n#'   \\item{\\code{KL_delta}}{Default is \\code{0.1}; interval range used when \\code{criteria = 'KL'}\n#'     or \\code{criteria = 'KLn'}}\n#'     \n#'   \\item{\\code{max_time}}{Default is \\code{Inf}; maximum time allowed for the generated GUI, measured\n#'     in seconds. For instance, if the test should stop after 10 minutes then the number \n#'     600 should be passed (10 * 60)}\n#'   \n#' }\n#' \n#' @param shinyGUI a list of GUI based parameters to be over-written. These can be\n#' \n#' \\describe{\n#'   \\item{\\code{title}}{A character string for the test title. Default is \n#'     \\code{'mirtCAT'}}\n#'   \n#'   \\item{\\code{authors}}{A character string for the author names. Default is \n#'     \\code{'Author of survey'}}\n#'\n#'   \\item{\\code{firstpage}}{The first page of the shiny GUI. Default prints the title\n#'     and information message\n#'     \n#'     \\preformatted{ \n#'          list(h1('Welcome to the mirtCAT interface'),\n#'               The following interface was created using the mirtCAT package. \n#'               To cite the package use citation(\\\\'mirtCATd\\\\') in R.')\n#'          }\n#'       }\n#' \n#'   \\item{\\code{demographics}}{The person information page used in the GUI for collecting \n#'     demographic information generated using tools from the shiny package. The default \n#'     collects only the respondent gender using the format \n#'  \n#'     \\preformatted{ \n#'          list(selectInput(inputId = 'gender',\n#'                   label = 'Please select your gender.',\n#'                   choices = c('', 'Male', 'Female', 'Other'),\n#'                   selected = ''))\n#'         }\n#'      }\n#'      \n#'   \\item{\\code{demographics_inputIDs}}{a character vector required if a custom demographics\n#'     input is used. Default is \\code{demographics_inputIDs = 'gender'}, corresponding to\n#'     the \\code{demographics} default}\n#'     \n#'   \\item{\\code{stem_locations}}{a character vector of paths pointing to .png or .jpeg \n#'     files to be used as item stems. Must be the length of the test, where \\code{NA}s are \n#'     used if the item has no corresponding file}\n#'     \n#'   \\item{\\code{lastpage}}{Last message indicating that the test has been completed \n#'     (i.e., criteria has been met). Default is \n#'   \n#'     \\preformatted{list(h5(\"End of survey. Click \\'Next\\' to save results \n#'       and close application.\"))}\n#'    }    \n#'   \n#' }\n#' \n#' @param preCAT a list object which can be used. This \n#'   specifies a pre-CAT block in which different test properties may be applied. If the\n#'   list is empty no preCAT block will be used. All of the following elements are required.\n#'   \n#'   \\describe{\n#'     \\item{\\code{nitems}}{number of items to administer before the CAT session begins.\n#'       An input greater than 0 is required}\n#'     \n#'     \\item{\\code{criteria}}{selection criteria (see above). Default is 'random'}\n#'     \n#'     \\item{\\code{method}}{selection criteria (see above). It is generally recommended to \n#'       select a method which can deal with all-or-none response patterns, such as 'EAP'\n#'       or 'MAP'. Default is 'MAP'}\n#'    }\n#' \n#' @export mirtCAT\n#' @author Phil Chalmers \\email{rphilip.chalmers@@gmail.com}\n#' @seealso \\code{\\link{generate_pattern}}\n#' \n#' @return Returns a \\code{\\link{ReferenceClasses}} object of class \\code{'Person'} containing the\n#'   following fields. \n#'   \n#' \\describe{\n#'   \\item{\\code{raw_responses}}{A numeric vector indicating the raws responses to the respective\n#'     items, where NA indicates the item was not answered}\n#'     \n#'   \\item{\\code{responses}}{A numeric vector of scored responses if the \\code{item_answers} input\n#'     was used for each respective item}\n#'   \n#'   \\item{\\code{items_answered}}{An integer vector indicating the order in which the items were \n#'     answered}\n#'   \n#'   \\item{\\code{thetas}}{A numeric vector indicating the final theta estimates}\n#'   \n#'   \\item{\\code{thetas_history}}{A matrix indicating the progression of updating the theta values\n#'     during the test}\n#'     \n#'   \\item{\\code{thetas_SE_history}}{A matrix indicating the standard errors for theta after each\n#'     successive item was answered}\n#'     \n#'   \\item{\\code{item_time}}{A numeric vector indicating how long the respondent took to answer\n#'     each question (in seconds)}\n#' \n#'   \\item{\\code{demographics}}{A data.frame object containing the information collected on the \n#'     first page of the shiny GUI. This is used to store the demographic information for each\n#'     participant} \n#' }\n#' \n#' @keywords CAT, computerized adaptive testing\n#' \n#' @examples\n#' \\dontrun{\n#' \n#' #unidimensional scored example with generated items\n#' \n#' #model\n#' set.seed(1234)\n#' nitems <- 50\n#' itemnames <- paste0('Item.', 1:nitems)\n#' a <- matrix(rlnorm(nitems, .2, .3))\n#' d <- matrix(rnorm(nitems))\n#' dat <- simdata(a, d, 1000, itemtype = 'dich')\n#' colnames(dat) <- itemnames\n#' mod <- mirt(dat, 1)\n#' \n#' #simple math items\n#' shiny_questions <- questions <- vector('list', nitems)\n#' names(shiny_questions) <- names(questions) <- itemnames\n#' answers <- character(nitems)\n#' choices <- vector('list', nitems)\n#' spacing <- floor(d - min(d)) + 1 #easier items have more variation in the options\n#' \n#' for(i in 1:nitems){\n#'     n1 <- sample(1:50, 1)\n#'     n2 <- sample(51:100, 1)\n#'     ans <- n1 + n2\n#'     questions[[i]] <- paste0(n1, ' + ', n2, ' = ?')\n#'     answers[i] <- as.character(ans)\n#'     ch <- ans + sample(c(-5:-1, 1:5) * spacing[i,], 5)\n#'     ch[sample(1:5, 1)] <- ans\n#'     choices[[i]] <- as.character(ch)\n#' }\n#' \n#' for(i in 1L:nitems){\n#'     shiny_questions[[i]] <- radioButtons(inputId = itemnames[i],\n#'                                          label = questions[[i]],\n#'                                          choices = choices[[i]])\n#' }\n#' \n#' mirtCAT(shiny_questions) #collect response only (no scoring or estimating thetas)\n#' mirtCAT(shiny_questions, mod, item_answers=answers) #sequential scoring \n#' mirtCAT(shiny_questions, mod, item_answers=answers, criteria = 'random') #random\n#' mirtCAT(shiny_questions, mod, item_answers=answers, criteria = 'MI') #adaptive\n#' \n#' #run locally, random response pattern given Theta\n#' set.seed(1)\n#' pat <- generate_pattern(mod, Theta = 0, choices = choices, item_answers=answers)\n#' head(pat)\n#' mirtCAT(shiny_questions, mod, item_answers=answers, local_pattern=pat)\n#' \n#' #same as above, but using special input vector that doesn't require shiny\n#' set.seed(1)\n#' pat2 <- generate_pattern(mod, Theta = 0)\n#' head(pat2)\n#' mirtCAT(mirt_object=mod, local_pattern=pat2)\n#' \n#' #run CAT, and save results to object called person\n#' person <- mirtCAT(shiny_questions, mod, item_answers=answers, criteria = 'MI', \n#'   local_pattern=pat)\n#' print(person)\n#' summary(person)\n#' \n#' #plot the session\n#' plot(person) #standard errors\n#' plot(person, SE=1.96) #95 percent confidence intervals\n#' }\nmirtCAT <- function(questions = NULL, mirt_object = NULL, method = 'MAP', criteria = 'seq', \n                    item_answers = NULL, start_item = 1, \n                    exposure = rep(1, length(questions)), local_pattern = NULL,\n                    design = list(), shinyGUI = list(), preCAT = list())\n{    \n    if(is.null(questions)){\n        questions <- vector('list', ncol(mirt_object@Data$data))\n        Names <- colnames(mirt_object@Data$data)\n        names(questions) <- Names\n        K <- mirt_object@Data$K\n        for(i in 1L:length(K))\n            questions[[i]] <- selectInput(inputId = Names[i], label = '', \n                                          choices = as.character(0L:(K[i]-1L)))\n        item_answers <- NULL\n    }\n        \n    if(is.null(names(questions)))\n        stop('questions list must have names')\n    if(is.null(mirt_object)){\n        dat <- matrix(c(0,1), 2L, length(questions))\n        colnames(dat) <- names(questions)\n        mirt_object <- mirt(dat, 1L, TOL=NaN)\n        score <- FALSE\n        if(!(criteria %in% c('seq', 'random')))\n            stop('Only random and seq criteria are available if no mirt_object was defined')\n    } else score <- TRUE\n    itemnames <- colnames(mirt_object@Data$data)\n    if(length(itemnames) != length(questions) || !all(itemnames %in% names(questions)))\n        stop('Item names for mirt_object and questions do not match')\n    item_options <- lapply(questions, extract_choices)\n    \n    #setup objects\n    shinyGUI_object <- ShinyGUI$new(questions=questions, shinyGUI=shinyGUI)\n    test_object <- Test$new(mirt_object=mirt_object, item_answers_in=item_answers, \n                     item_options=item_options, quadpts_in=design$quadpts,\n                     theta_range_in=design$theta_range)\n    design_object <- Design$new(method=method, criteria=criteria, start_item=start_item,\n                         nfact=test_object$nfact, design=design, exposure=exposure,\n                         preCAT=preCAT, nitems=test_object$length)\n    person_object <- Person$new(nfact=test_object$nfact, nitems=length(test_object$itemnames), \n                         thetas.start_in=design$thetas.start, score=score)\n        \n    #put in specific enviroment\n    MCE$person <- person_object\n    MCE$test <- test_object\n    MCE$design <- design_object\n    MCE$shinyGUI <- shinyGUI_object\n    MCE$STOP <- FALSE\n    MCE$outfile <- tempfile(fileext='.png')\n    \n    if(length(local_pattern)){\n        person <- run_local(as.character(local_pattern))\n        person$item_time <- numeric(0)\n    } else {\n        #run interface\n        runApp(list(ui = ui(), server = server), launch.browser=TRUE)\n        person <- MCE$person\n    }\n    person$items_answered <- person$items_answered[!is.na(person$items_answered)]\n    ret <- list(raw_responses=person$raw_responses, \n                responses=person$responses,\n                items_answered=person$items_answered,\n                thetas=person$thetas,\n                thetas_history=person$thetas_history,\n                thetas_SE_history=person$thetas_SE_history,\n                item_time=person$item_time,\n                demographics=person$demographics)\n    colnames(ret$thetas) <- colnames(ret$thetas_history) <-\n        colnames(ret$thetas_SE_history) <- paste0('Theta_', 1L:MCE$test$nfact)\n    if(!person$score)\n        ret$thetas <- ret$thetas_history <- ret$thetas_SE_history <- NA\n    MCE$person <- MCE$test <- MCE$design <- MCE$shinyGUI <- \n        MCE$STOP <- MCE$outfile <- NULL\n    class(ret) <- 'mirtCAT'\n    ret\n}",
    "created" : 1406070543027.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "250320362",
    "id" : "FD661F28",
    "lastKnownWriteTime" : 1407968272,
    "path" : "~/Desktop/Dropbox/Research-projects/mirtCAT/R/mirtCAT.R",
    "project_path" : "R/mirtCAT.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}