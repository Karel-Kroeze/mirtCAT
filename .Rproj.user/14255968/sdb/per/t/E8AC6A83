{
    "contents" : "#' @rdname mirtCAT\n#' @method print mirtCAT\n#' @param x object of class \\code{'mirtCAT'}\n#' @export\nprint.mirtCAT <- function(x, ...){\n    if(!all(is.na(x$thetas))){\n        person <- c(sum(!is.na(x$responses)),\n                          x$thetas[1L,],\n                          x$thetas_SE_history[nrow(x$thetas_SE_history),])        \n        names(person) <- c('n.items.answered', paste0('Theta_', 1:length(x$thetas)),\n                           paste0('SE.Theta_', 1:length(x$thetas)))\n        ret <- t(as.data.frame(person))\n        rownames(ret) <- ''\n        return(ret)\n    } else {\n        return(data.frame('n.items.answered' = sum(!is.na(x$responses))))\n    }\n}\n\n#' @rdname mirtCAT\n#' @method summary mirtCAT\n#' @param object object of class \\code{'mirtCAT'}\n#' @param sort logical; sort the response patterns based on the order they \n#'   were administered? If FALSE, the raw response patterns containing NAs will be returned\n#'   for items that were not administered\n#' @export\nsummary.mirtCAT <- function(object, sort = TRUE, ...){\n    pick <- if(sort){\n        object$items_answered\n    } else 1L:length(object$raw_responses)\n    raw_responses <- object$raw_responses[pick]\n    responses <- object$responses[pick]\n    ret <- list(raw_responses=raw_responses,\n                responses=responses,\n                items_answered=object$items_answered,\n                thetas_history=object$thetas_history, \n                thetas_SE_history=object$thetas_SE_history,\n                demographics=object$demographics)\n    if(length(object$item_time))\n        ret$item_time <- object$item_time[pick]\n    if(length(ret$thetas_history) == 1L || is.na(ret$thetas_history))\n        ret$thetas_history <- ret$thetas_SE_history <- NULL\n    if(all(ret$raw_responses == ret$responses, na.rm = TRUE))\n        ret$raw_responses <- NULL\n    if(!length(object$demographics))\n        ret$demographics <- NULL\n    ret\n}\n\n#' @rdname mirtCAT\n#' @method plot mirtCAT\n#' @param pick_theta a number indicating which theta to plot (only applicable for multidimensional \n#'   tests). The default is to facet each theta on one plot, but to plot only the first factor pass\n#'   \\code{pick_theta = 1}   \n#' @param main title of the plot. Will default to \\code{'CAT Standard Errors'} or \n#'   \\code{'CAT ##\\% Confidence Intervals'} depending on the SE input\n#' @param SE size of the standard errors to plot. The default is 1, and therefore plots the\n#'   standard error. To obtain the 95\\% interval use \\code{SE = 1.96} (from the z-distribution)\n#' @param ... additional arguments to be passed to \\code{lattice}\n#' @export\nplot.mirtCAT <- function(x, pick_theta = NULL, SE = 1, main = NULL, ...){\n    if(length(x$thetas_SE_history) == 1L || is.na(x$thetas_SE_history))\n        stop('plot not available for non-adaptive tests')\n    p <- floor((1-(pnorm(-abs(SE))*2))*100)\n    if(is.null(main)){\n        if(SE == 1)\n            main <- 'CAT Standard Errors'\n        else main <- paste0('CAT ', p, '% Confidence Intervals')\n    }\n    nfact <- ncol(x$thetas)\n    thetas <- data.frame(x$thetas_history)\n    thetasSEhigh <- data.frame(thetas + x$thetas_SE_history*SE)\n    thetasSElow <- data.frame(thetas - x$thetas_SE_history*SE)\n    labels <- paste0('Theta_', 1L:nfact)\n    if(!is.null(pick_theta) && nfact > 1L){\n        nfact <- 1L\n        labels <- labels[pick_theta]\n        thetas <- thetas[,pick_theta, drop=FALSE]\n        thetasSEhigh <- thetasSEhigh[,pick_theta, drop=FALSE]\n        thetasSElow <- thetasSElow[,pick_theta, drop=FALSE]\n    }\n    thetaslong <- reshape(thetas, varying = list(colnames(thetas)), idvar = 'id', \n                          direction = 'long', timevar = 'thetas')\n    thetaslong$thetas <- factor(thetaslong$thetas, labels = labels)\n    thetasSElowlong <- reshape(thetasSElow, varying = list(colnames(thetasSElow)), idvar = 'id', \n                               direction = 'long', timevar = 'thetasSE')\n    thetasSEhighlong <- reshape(thetasSEhigh, varying = list(colnames(thetasSEhigh)), idvar = 'id', \n                                direction = 'long', timevar = 'thetasSE')\n    colnames(thetaslong) <- colnames(thetasSElowlong) <- colnames(thetasSEhighlong) <-\n        c('thetas', 'F1', 'id')\n    tmp <- x$items_answered\n    tmp <- rep(c(0,tmp[!is.na(tmp)]), nfact)\n    thetaslong$item <- factor(tmp, levels = unique(tmp))\n    if(nfact > 1L){\n        return(xyplot(F1 ~ item|thetas, data=thetaslong, \n                      main = main,\n                      lower = thetasSElowlong$F1,\n                      upper = thetasSEhighlong$F1,\n                      panel = function(x, y, lower, upper, subscripts, ...){\n                          lower <- lower[subscripts]; upper <- upper[subscripts]\n                          panel.polygon(c(x, rev(x)), c(upper, rev(lower)), \n                                        col=grey(.9), border = FALSE, ...)\n                          panel.points(x, y, ...)\n                          panel.lines(x, y, ...)\n                      },\n                      ylim=c(min(thetasSElowlong$F1)-.1, max(thetasSEhighlong$F1)+.1),\n                      ylab = expression(theta), \n                      xlab = 'Item', ...))\n        \n    } else {\n        return(xyplot(F1 ~ item, data=thetaslong, \n                      main = main,\n                      lower = thetasSElowlong$F1,\n                      upper = thetasSEhighlong$F1,\n                      panel = function(x, y, lower, upper, subscripts, ...){\n                          panel.polygon(c(x, rev(x)), c(upper, rev(lower)), \n                                        col=grey(.9), border = FALSE, ...)\n                          panel.points(x, y, ...)\n                          panel.lines(x, y, ...)\n                      },\n                      ylim=c(min(thetasSElowlong$F1)-.1, max(thetasSEhighlong$F1)+.1),\n                      ylab = expression(theta), \n                      xlab = 'Item', ...))\n    }\n}",
    "created" : 1407967984977.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "608816062",
    "id" : "E8AC6A83",
    "lastKnownWriteTime" : 1407968460,
    "path" : "~/Desktop/Dropbox/Research-projects/mirtCAT/R/zzz-methods.R",
    "project_path" : "R/zzz-methods.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}